#!/usr/bin/env bash
#
# $Info: build version 1.0 $

function Die() { echo "FAILED to build! $*" 1>&2; return 1; }

function Build()
{
  local SYNTAX
  SYNTAX="
  NAME
  ----

  $0 - use cmake to build and optionally run, test, or install

  ## SYNOPSIS

    $0 -h|--help
    $0 [-n] [-C DIR] [-debug][-verbose][-quiet][-clean][-run|-test|-install] [BUILD_OPTIONS] [ -- TEST_OPTIONS -- RUNTIME_ARGS]


  ## DESCRIPTION

  This script was written to simplify using _cmake_ and educate along they. It provides a single command to configure, compile, link and run or test projects.  It assume a proper CMakeLists.txt has been setup. Bascially, all this does is:

  + clean -a # OPTIONAL
  + cmake -B build
  + cmake --build build
  + ctest --test-dir build # OPTIONAL -OR- run
  + cmake --install --config Debug

  IMPORTANT: This should be run at the top of the project where the CMakeLists.txt file containing the project keyword exists.

  ## OPTIONS

  + -help    Display this text
  + -n       Don't actually do anything except show commands that would have been done
  + -B DIR   Name of build directory -- defaults to \"build\"
  + -C DIR   Change to specified directory before doing anything else
  + -clean   Remove all build files and other output bits
  + -debug   Output information to help debug CMakeLists.txt etc.
  + -quiet   Remove verbosity when -test invoked
  + -P DIR   Set PROJECT_DIR. PROJECT_DIR should contain .git/
  + -run     When done building, run the executable
  + -S DIR   Name of source directory -- defaults to \".\"
  + -test    When done building, run the tests verbosely unless -q supplied
  + -install When done building, install
  + -targets List explicit targets
  + -verbose Adds more information to output. Opposite of quiet.

  ## CONFIGURATION

    Several variables are setup inside the script for the default locations.

  ## EXAMPLES

  % build
  % build -clean -test
  % build -run

  "

  # Setup
  #------------------------------------------------------------------------------
  export SUBPROJ_DIR DEBUG
  local SRC_DIR BLD_DIR CLEAN DEBUG INSTALL PREFIX OPTS_SEP QUIET
  SRC_DIR="."
  BLD_DIR="build"
  SUBPROJ_DIR="$(pwd)"
  APPS="${HOME}/.local/apps"
  CLEAN=0
  DEBUG=""
  QUIET=0
  INSTALL=0
  PREFIX=
  ACTION=
  OPTS_SEP=0
  declare -a BUILD_OPTS TEST_OPTS
  BUILD_OPTS=()
  TEST_OPTS=()

  local SCRIPTS_DIR
  SCRIPTS_DIR="$(dirname "$0")"
  if [[ ! -f "${SCRIPTS_DIR}/Essential-IO" ]]; then
    SCRIPTS_DIR="${HOME}/.local/scripts"
  fi
  if [[ ! -f "${SCRIPTS_DIR}/Essential-IO" ]]; then
    Die "Unable to find Essential-IO in ${SCRIPTS_DIR}"
  fi
  # shellcheck disable=SC1091
  source "${SCRIPTS_DIR}/Essential-IO"
  Logfile build.log
  Log "% $0 $*"

  #------------------------------------------------------------------------------
  # Scan for command-line options
  #------------------------------------------------------------------------------
  export PROJECT_DIR
  PROJECT_DIR="" ;#< Do not allow environment in
  while [[ $# != 0 ]]; do
    if   [[ "$1" =~ ^-{1,2}h(elp)?$ ]]; then
      Echo "${SYNTAX}"; return 0
    elif [[ "$1" == "-B" ]]; then
      if [[ $# -lt 2 ]]; then
        Report_error "-B requires a directory argument"
      else
        BLD_DIR="$2"
        shift
      fi
    elif [[ "$1" == "-C" ]]; then
      if [[ $# -lt 2 ]]; then
        Report_error "-C requires a directory argument"
      elif [[ ! -d "$2" ]]; then
        Report_error "'$2' is not a directory as required by -C"
      else
        if ! cd "$2"; then
          Report_error "Failed to change directory!?"; return 1;
        fi
        SUBPROJ_DIR="$(pwd)"
        shift
      fi
    elif [[ "$1" == "-P" ]]; then
      if [[ $# -lt 2 ]]; then
        Report_error "-P requires a directory argument"
      elif [[ ! -d "$2" ]]; then
        Report_error "'$2' is not a directory as required by -P"
      else
        PROJECT_DIR="$2"
        if [[ ! -d "$2/.git" ]]; then
          Report_warning "'$2' does not contain .git/ as recommended."
        fi
        shift
      fi
    elif [[ "$1" == "-S" ]]; then
      if [[ $# -lt 2 ]]; then
        Report_error "-S requires a directory argument"
      elif [[ ! -d "$2" ]]; then
        Report_error "'$2' is not a directory as required by -S"
      else
        SRC_DIR="$2"
        shift
      fi
    elif [[ "$1" == "-n" ]]; then
      export NOTREALLY
      NOTREALLY="-n"
    elif [[ "$1" =~ ^-{1,2}clean$ ]]; then
      CLEAN=1;
    elif [[ "$1" =~ ^-{1,2}debug$ ]]; then
      DEBUG="--debug-output";
    elif [[ "$1" =~ ^-{1,2}quiet$ ]]; then
      QUIET=1;
    elif [[ "$1" =~ ^-{1,2}verbose$ ]]; then
      QUIET=0
    elif [[ "$1" =~ ^-{1,2}install$ ]]; then
      INSTALL=1
    elif [[ "$1" =~ ^--prefix$ ]]; then
      PREFIX="$2"
      if [[ ! -d "${PREFIX}" ]]; then
        PREFIX=""
        Report_error "--prefix must be followed by a valid installation directory"; return 1;
      else
        shift
      fi
    elif [[ "$1" =~ ^-{1,2}(list-)?targets$ ]]; then
      ACTION="list"
    elif [[ "$1" =~ ^-{1,2}test$ ]]; then
      ACTION="test"
    elif [[ "$1" =~ ^-{1,2}run$ ]]; then
      ACTION="run"
    elif [[ "$1" == "--" && ${OPTS_SEP} == 0 ]]; then
      OPTS_SEP=1
    elif [[ ${OPTS_SEP} == 0 ]]; then
      BUILD_OPTS=("${BUILD_OPTS[@]}" "$1")
    elif [[ "$1" =~ ^-v$ ]]; then
      BUILD_OPTS=("-v")
    elif [[ "$1" =~ ^-V$ ]]; then
      TEST_OPTS=("-V")
    else
      TEST_OPTS=("${TEST_OPTS[@]}" "$1")
    fi
    shift
  done
  if [[ -z "${PROJECT_DIR}" ]]; then
    PROJECT_DIR="$(git rev-parse --show-toplevel)" || Die "Not in git repo"
  fi

  if [[ ${QUIET} == 0 ]]; then
    TEST_OPTS=(-V "${TEST_OPTS[@]}")
  fi

  #-------------------------------------------------------------------------------
  # Validate environment
  #-------------------------------------------------------------------------------
  if [[ ! -r CMakeLists.txt ]]; then
    Report_error "Missing CMakeLists.txt!"
    return 1
  elif ! grep '^cmake_minimum_required' CMakeLists.txt; then
    Report_error "CMakeLists.txt missing cmake_minimum_required directive -- are you in the right directory?"
    return 1
  elif ! grep '^project' CMakeLists.txt; then
    Report_error "CMakeLists.txt missing project directive -- are you in the right directory?"
    return 1
  fi

  # shellcheck disable=SC2016
  PERLSCRIPT='
  chomp; chomp;
  next if m{[{}]};
  print " $2" if m{(add_executable|set_target)[( "]+([^" )]+)};
  '
  TARGETS="$(/usr/bin/perl -ne "${PERLSCRIPT}" CMakeLists.txt)"
  if [[ "${ACTION}" == list ]]; then
    Report_info "Targets are ${TARGETS}"
    return 0
  fi
  #-------------------------------------------------------------------------------
  # Locate cmake modules that we assume
  #-------------------------------------------------------------------------------
  export CMAKE_PREFIX_PATH
  CMAKE_PREFIX_PATH=
  for CDIR in "${SUBPROJ_DIR}" "${PROJECT_DIR}" "${PROJECT_DIR}/externs" "${APPS}" "${APPS}/lib"; do
    if [[ -d "${CDIR}/cmake" || -d "${CDIR}/lib/cmake" ]]; then
      if [[ -z "${CMAKE_PREFIX_PATH}" ]]; then
        CMAKE_PREFIX_PATH="${CDIR}"
      else
        CMAKE_PREFIX_PATH="${CMAKE_PREFIX_PATH};${CDIR}"
      fi
    fi
  done

  #------------------------------------------------------------------------------
  # Add horizontal line to help if visually scrolling backward
  #------------------------------------------------------------------------------
  Ruler
  #! cd "${SUBPROJ_DIR}" || Die "Unable to enter ${SUBPROJ_DIR}" # Should not be needed

  if [[ -n "${DEBUG}" ]]; then
    Report_debug -f "CMAKE_PREFIX_PATH=${CMAKE_PREFIX_PATH}"
  fi

  #------------------------------------------------------------------------------
  # Optionally start with a clean slate
  #------------------------------------------------------------------------------
  if [[ ${CLEAN} == 1 ]]; then
    Report_info "Cleaning ${SUBPROJ_DIR}"
    _do rm -fr "${BLD_DIR}"
  fi

  #------------------------------------------------------------------------------
  Report_info "Configuring ${SUBPROJ_DIR}"
  if [[ -z "${CMAKE_PREFIX_PATH}" ]]; then
    _do cmake -S "${SRC_DIR}" -B "${BLD_DIR}" "${DEBUG}" || return 1
  else
    _do cmake -S "${SRC_DIR}" -B "${BLD_DIR}" -DCMAKE_PREFIX_PATH="${CMAKE_PREFIX_PATH}" "${DEBUG}"|| return 1
  fi

  #------------------------------------------------------------------------------
  Report_info "Compiling ${SUBPROJ_DIR}"
  # shellcheck disable=SC2086
  _do cmake --build "${BLD_DIR}" "${BUILD_OPTS[@]}" || return 1

  #------------------------------------------------------------------------------
  if [[ "${ACTION}" == run ]]; then
    Report_info "Running ${SUBPROJ_DIR}"
    if [[ -n "${TARGETS}" ]]; then
      for EXECUTABLE in ${TARGETS}; do
        # shellcheck disable=SC2086,SC2312
        ( _do "${BLD_DIR}/${EXECUTABLE}" "${TEST_OPTS[@]}" || return 1 ) 2>&1 | tee run.log
      done
    else
      Report_error "Not sure what to run!"
    fi
  elif [[ "${ACTION}" == test ]]; then
    Report_info "Testing ${SUBPROJ_DIR}"
    # shellcheck disable=SC2086,SC2312
    ( _do ctest --test-dir "${BLD_DIR}" "${TEST_OPTS[@]}" || return 1 ) 2>&1 | tee test.log
  elif [[ -x "${BLD_DIR}/${EXECUTABLE}" ]]; then
    if grep -q add_test CMakeLists.txt; then
      Report_info "Executable is in ${BLD_DIR}/${EXECUTABLE} -- HINT: Next time try adding -test."
    else
      Report_info "Executable is in ${BLD_DIR}/${EXECUTABLE} -- HINT: Next time try adding -run."
    fi
  else
    Report_info "Executables in ${BLD_DIR}/"
  fi

  #------------------------------------------------------------------------------
  if [[ ${INSTALL} == 1 ]]; then
    if [[ -n "${PREFIX}" ]]; then
      Report_info "Installing ${SUBPROJ_DIR}"
      _do cmake --install "${BLD_DIR}" --config Debug --prefix "${PREFIX}"
    else
      Report_info "Installing ${SUBPROJ_DIR}"
      _do cmake --install "${BLD_DIR}" --config Debug
    fi
  fi
}

Build "$@"

# vim:nospell
