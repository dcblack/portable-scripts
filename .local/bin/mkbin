#!/bin/bash

# shellcheck disable=SC2312

function Realpath() {
  /usr/bin/perl '-MCwd(abs_path)' -le '$p=abs_path(join(q( ),@ARGV));print $p if -e $p' "$*"
}

function mkbin_help()
{
  cat <<'DOCUMENTATION'
## NAME

mkbin - Create an executable script

## SYNOPSIS

**mkbin** _OPTIONS_ _EXECUTABLE_

## DESCRIPTION

Creates a new executable script with a bare minimum template. The result contains a hashbang and is made executable.

## OPTIONS

OPTION                | DESCRIPTION
------                | -----------
-/_HASHBANG_          | Specify an alternate hashbang line
-LANGUAGE             | Select a language: bash (default), csh, lua, perl, python2, python3, zsh
--bin\-b              | Place in $HOME/bin
--edit[=_editor_\|-e  | Enter the specified editor after creation
--help\|-h            | Display this text
--local\-l            | Place in $HOME/.local/bin
--notreally|-n        | Show what would be done
--quiet|-q            | Quiet
--raw|-r              | Raw (without more than hashbang line)
--script\|-s          | Place in scripts
--utils|-u            | Add utils.bash
--verbose|-v          | Verbose
-dir=_DIRECTORY_      | Place EXECUTABLE under DIRECTORY

DOCUMENTATION
}

#-------------------------------------------------------------------------------
function _C()
{
  export NOCOLOR
  if [[ ${NOCOLOR} == 1 ]]; then
    return
  fi
  if [[ $# == 0 ]]; then set none; fi
  export COLOR_SET COLOR_FG
  local ESC PRF
  if [[ -z "${COLOR_SET}" ]]; then # default
    COLOR_SET=10
  fi
  if [[ -z "${COLOR_FG}" ]]; then # default
    COLOR_FG=1
  fi
  ESC=""
  for arg in "$@"; do
    test -z "${arg}" && continue
    if [[ ${COLOR_FG} == 1 ]]; then
      case ${COLOR_SET} in
        2)  PRF="3"  ;;
        10) PRF="9"  ;;
        *)  return 1 ;;
      esac
    else
      case ${COLOR_SET} in
        2)  PRF="4"  ;;
        10) PRF="10" ;;
        *) return 1  ;;
      esac
    fi
    case "${arg}" in
      dflt|default)    COLOR_SET=2 ; COLOR_FG=1 ;;
      fg|foreground)   COLOR_FG=1 ;;
      bg|background)   COLOR_FG=0 ;;
      bright)          COLOR_SET=10 ;;
      norm|normal)     COLOR_SET=2 ;;
      -|none)          echo -n "${ESC}[0m" ; COLOR_FG=1 ;;
      bold)            echo -n "${ESC}[1m" ;;
      ubld|nobold)     echo -n "${ESC}[21m" ;;
      dark)            echo -n "${ESC}[2m" ;;
      udrk|nodark)     echo -n "${ESC}[22m" ;;
      undr|under*)     echo -n "${ESC}[4m" ;;
      blnk|blink)      echo -n "${ESC}[5m" ;;
      noun*)           echo -n "${ESC}[24m" ;;
      nblk|noblink)    echo -n "${ESC}[25m" ;;
      rev*)            echo -n "${ESC}[8m" ;;
      invs|invi*)      echo -n "${ESC}[8m" ;;
      unvs|visi*)      echo -n "${ESC}[27m" ;;
      blk|black)       echo -n "${ESC}[${PRF}0m" ;;
      red)             echo -n "${ESC}[${PRF}1m" ;;
      grn|green)       echo -n "${ESC}[${PRF}2m" ;;
      ylw|yellow)      echo -n "${ESC}[${PRF}3m" ;;
      blu|blue)        echo -n "${ESC}[${PRF}4m" ;;
      mag|magenta)     echo -n "${ESC}[${PRF}5m" ;;
      cyn|cyan)        echo -n "${ESC}[${PRF}6m" ;;
      wht|white)       echo -n "${ESC}[${PRF}7m" ;;
      *)               return 1 ;;
    esac
  done
  echo ""
}


#-------------------------------------------------------------------------------
function Regex
{
  perl -e 'if ($ARGV[1]=~m/$ARGV[2]/){exit 0;}else{exit 1;}' - "$1" "$2"
}


function Report_error()
{
  local NONE
  NONE="$(_C none)"
  echo "$(_C bold bright red)Error:$(_C none) $*" 1>&2
}

function Verbose_info()
{
  if [[ "$1" != 1 ]]; then return; fi
  shift
  local NONE
  NONE="$(_C none)"
  echo "$(_C bold bright green)Info:${NONE} $*"
}

#-------------------------------------------------------------------------------
function Mkbin()
{
  local CRED NONE
  CRED="$(_C bright red)"
  CCYN="$(_C bright cyan)"
  CBLU="$(_C bright blue)"
  NONE="$(_C none)"
  local HASHBANG DIRECTORY EDIT SCRIPT SCRIPT_NAME SCRIPT_PATH
  local OPTION CMNT KIND IS_NEW ADD_TAIL ADD_UTILS FIRST_LINE V N
  ADD_TAIL=0
  ADD_UTILS=0
  KIND="bash"
  HASHBANG="/usr/bin/env bash"
  DIRECTORY=""
  EDIT=""
  CMNT="#"
  N=0
  R=0
  V=1
  while [[ "$1" =~ ^- ]]; do
    OPTION="$1"
    shift
    if [[ "${OPTION}" =~ ^-{1,2}h(elp)?$ ]]; then
      mkbin_help
      exit 1
    elif Regex "${OPTION}" "^/" ; then
      HASHBANG="${OPTION}"
    elif [[ "${OPTION}" =~ ^-{1,2}lua ]]; then
      KIND="lua"
      HASHBANG="/usr/bin/env lua"
    elif [[ "${OPTION}" =~ ^-{1,2}perl[45]? ]]; then
      KIND="perl"
      HASHBANG="/usr/bin/env perl5"
    elif [[ "${OPTION}" =~ ^-{1,2}py(thon)?2 ]]; then
      KIND="python"
      HASHBANG="/usr/bin/env python2"
    elif [[ "${OPTION}" =~ ^-{1,2}py(thon)?3? ]]; then
      KIND="python"
      HASHBANG="/usr/bin/env python3"
    elif [[ "${OPTION}" =~ ^-{1,2}zsh ]]; then
      KIND="zsh"
      HASHBANG="/usr/bin/env zsh"
    elif [[ "${OPTION}" =~ ^-{1,2}t?csh ]]; then # --csh|--tcsh
      KIND="csh"
      HASHBANG="/usr/bin/env csh"
    elif [[ "${OPTION}" =~ ^-{1,2}(ba)?sh ]]; then # --bash|--sh
      KIND="bash"
      HASHBANG="/usr/bin/env bash"
    elif [[ "${OPTION}" =~ ^-{1,2}e(dit)? ]]; then # --edit
      if [[ -n "${VISUAL}" ]]; then
        EDIT="${VISUAL}"
      else
        EDIT="gvim"
      fi
    elif [[ "${OPTION}" =~ ^-{1,2}b(in)? ]]; then # --bin
      if [[ -z "${DIRECTORY}" ]]; then
        if [[ -d ${HOME}/bin ]]; then
          DIRECTORY="${HOME}/bin"
        else
          Report_error "Unable to determine where the bin directory is located!"; return 1
        fi
      elif [[ -d "${DIRECTORY}/bin" ]]; then
        DIRECTORY="${DIRECTORY}/bin"
      else
        Report_error "Missing ${DIRECTORY}/bin ?!"; return 1
      fi
    elif [[ "${OPTION}" =~ ^-{1,2}l(ocal)? ]]; then # --local
      if [[ -z "${DIRECTORY}" ]]; then
        if [[ -d ${HOME}/.local/bin ]]; then
          DIRECTORY="${HOME}/.local/bin"
        else
          Report_error "Unable to determine where the bin directory is located!"; return 1
        fi
      elif [[ -d "${DIRECTORY}/.local/bin" ]]; then
        DIRECTORY="${DIRECTORY}/.local/bin"
      else
        Report_error "Missing ${DIRECTORY}/.local/bin ?!"; return 1
      fi
    elif [[ "${OPTION}" =~ ^-{1,2}s(cript)? ]]; then
      if [[ -z "${DIRECTORY}" ]]; then
        if [[ -d ${HOME}/scripts ]]; then
          DIRECTORY="${HOME}/scripts"
        elif [[ -d ${HOME}/.local/scripts ]]; then
          DIRECTORY="${HOME}/.local/scripts"
        else
          Report_error "Unable to determine where the scripts directory is located!" ; return 1
        fi
      elif [[ -d "${DIRECTORY}/scripts" ]]; then
        DIRECTORY="${DIRECTORY}/scripts"
      else
        Report_error "Missing ${DIRECTORY}/scripts ?!"; return 1
      fi
    elif [[ "${OPTION}" =~ ^-{1,2}d(ir)? ]]; then
      if Regex "${OPTION}" "=" ; then
        DIRECTORY="${1:s/.*=/}"
      elif [[ $# -gt 0 ]]; then
        DIRECTORY="$1"
        shift
      else
        Report_error "-dir must specify a directory"; return 1
      fi
    elif [[ "${OPTION}" =~ ^-{1,2}t(ail)? ]]; then
      ADD_TAIL=1
    elif [[ "${OPTION}" =~ ^-{1,2}u(tils)? ]]; then
      ADD_UTILS=1
    elif [[ "${OPTION}" =~ ^-{1,2}n(otreally)? ]]; then
      N=1
    elif [[ "${OPTION}" =~ ^-{1,2}noraw ]]; then
      R=0
    elif [[ "${OPTION}" =~ ^-{1,2}r(aw)? ]]; then
      R=1
    elif [[ "${OPTION}" =~ ^-{1,2}q(uiet)? ]]; then
      V=0
    elif [[ "${OPTION}" =~ ^-{1,2}v(erbose)? ]]; then
      V=1
    else
      Report_error "Unknown option '${OPTION}'"
    fi
  done

  # Grab name of script
  if [[ $# != 1 ]]; then
    Report_error "Missing script name!"; return 1
  fi
  local BASENAME="$1"
  if [[ "${BASENAME}" =~ .*/.* ]]; then
    DIRECTORY="$(dirname "${BASENAME}")"
    BASENAME="$(basename "${BASENAME}")"
  fi

  if [[ -z "${DIRECTORY}" ]]; then
    SCRIPT="${BASENAME}"
  elif [[ -d "${DIRECTORY}" ]]; then
    SCRIPT="${DIRECTORY}/${BASENAME}"
  else
    Report_error "Bad directory specification: ${DIRECTORY}"; return 1
  fi
  shift

  SCRIPT_NAME="${SCRIPT/*\/}"
  if [[ -s "${SCRIPT}" ]]; then
    SCRIPT_PATH="$(Realpath "${SCRIPT}")"
    if [[ ${N} == 1 ]]; then
      Verbose_info "${N}" "Would update ${CRED}${KIND}${NONE} script \"${SCRIPT}\""
      exit 0;
    fi
    Verbose_info "${V}" "Updating ${CRED}${KIND}${NONE} script \"${CBLU}${SCRIPT}${NONE}\""
    IS_NEW=0
    perl -pi -e 'our $hb; BEGIN{$hb=shift @ARGV;} if($.== 1 and not m/^#/){ s{^}{#$hb\n};}' "${HASHBANG}" "${SCRIPT}"
  else
    if [[ ${N} == 1 ]]; then
      Verbose_info "${N}" "Would create ${CRED}${KIND}${NONE} script \"${SCRIPT}\""
      exit 0;
    fi
    # Create file with hashbang line
    printf "#%s\n" "${HASHBANG?}" >"${SCRIPT}"
    printf "%s\n%s\$Info: %s - {:ONE_LINE_DESCRIPTION_HERE:}. \$\n\n" "${CMNT}" "${CMNT}" "${SCRIPT_NAME}" >>"${SCRIPT}"
    IS_NEW=1
    SCRIPT_PATH="$(Realpath "${SCRIPT}")"
    Verbose_info "${V}" "Creating ${CRED}${KIND}${NONE} script \"${SCRIPT_PATH}\""
  fi

  # Add ! to hashbang if needed
  perl -pi -e 'if($.== 1){ s{^#/}{#\041/};}' "${SCRIPT}"

  FIRST_LINE="$(head -n 1 "${SCRIPT}")"
  Verbose_info "${V}" "${FIRST_LINE}"

  # Add essentials
  if [[ ${IS_NEW} == 1 && ${R} == 0 ]]; then
    case "${KIND}" in
      bash)
        Verbose_info "${V}" "Added essentials"
        cat >> "${SCRIPT}" <<'EOT'
          ---> function Realpath ()
          ---> {
          --->   /usr/bin/perl '-MCwd(abs_path)' -le '$p=abs_path(join(q( ),@ARGV));print $p if -e $p' "$*"
          ---> }
          ---> SCRIPTDIR="$(Realpath "$(dirname "$0")"/../scripts)"
          ---> if [[ ! -d "${SCRIPTDIR}" ]]; then
          --->   printf "FATAL: Missing required directory '%s'\n" "${SCRIPTDIR}"
          --->   crash
          ---> fi
          ---> # shellcheck disable=SC2250,SC1091
          ---> source "$SCRIPTDIR/Essential-IO"

EOT
        perl -pi -e 's/^ +---> //' "${SCRIPT}"
        ;;
      perl)
        Verbose_info "${V}" "Added strict"
        cat >> "${SCRIPT}" <<'EOT'
          ---> require v5.6;
          ---> use strict;
          ---> use warnings;
          ---> use Cwd qw(abs_path getcwd);
          ---> use English;
          ---> use File::Basename;
          ---> use FileHandle;
          ---> use FindBin qw($RealBin $RealScript);
          ---> use Getopt::Long;
          ---> use Pod::Usage;
          ---> STDOUT->autoflush(1);
          ---> STDERR->autoflush(1);

EOT
        perl -pi -e 's/^ +---> //' "${SCRIPT}"
        ;;
      *)
        ;;
    esac
  fi

  # Add utilities if requested
  if [[ ${ADD_UTILS} == 1 ]]; then
    case "${KIND}" in
      bash)
        Verbose_info "${V}" "Added util.bash"
        cat >> "${SCRIPT}" <<'EOT'
          ---> SCRIPT="$(Realpath "$0")"
          ---> SCRIPT="$(dirname "${SCRIPT}")/utils.bash"
          ---> if [[ -x "${SCRIPT}" ]]; then
          --->   # shellcheck source=utils.bash disable=SC1091
          --->   source "${SCRIPT}" "$0"
          ---> else
          --->   echo "Error: Missing ${SCRIPT}" 1>&2; exit 1
          ---> fi

EOT
        perl -pi -e 's/^ +---> //' "${SCRIPT}"
        ;;
      perl)
        Verbose_info "${V}" "Added command-line parsing"
        cat >> "${SCRIPT}" <<'EOT'
          ---> #------------------------------------------------------------------------------
          ---> # Parse command-line
          ---> #------------------------------------------------------------------------------
          ---> my $POD2MAN_BIN = 'pod2man';
          ---> our @ORIG = @ARGV;
          ---> our %opts;
          ---> GetOptions(\%opts,
          --->   'help',
          --->   'man',
          --->   'nroff',
          --->   'usage',
          ---> )  or pod2usage(-verbose => 0);
          ---> if (exists $opts{'usage'} ) {
          --->   pod2usage(-exitval => 0, -verbose => 0);
          ---> }
          ---> if (exists $opts{'man'} ) {
          --->   pod2usage(-exitval => 0, -verbose => 2);
          ---> }
          ---> if (exists $opts{'nroff'} ) {
          --->   open SCRIPT,"$POD2MAN_BIN --name='Scratch tools' $RealBin/$RealScript|";
          --->   print grep($_ ne '',<SCRIPT>);
          --->   close SCRIPT;
          --->   exit 0;
          ---> }
          ---> if (exists $opts{'help'}) {
          --->   pod2usage(-verbose => 1);
          ---> }

          ---> #------------------------------------------------------------------------------
          ---> # Main
          ---> #------------------------------------------------------------------------------
EOT
        perl -pi -e 's/^ +---> //' "${SCRIPT}"
        ;;
    *)
      ;;
    esac
  fi

  # Add tail
  if [[ ${ADD_TAIL} == 1 && ${R} == 0 ]]; then
    case "${KIND}" in
      perl)
        Verbose_info "${V}" "Added tail"
        cat >> "${SCRIPT}" <<'EOT'
          ---> exit 0;
          ---> __DATA__
          ---> =pod

          ---> =head1 NAME

          ---> {:SCRIPT_NAME:} - {:ONE_LINE_SUMMARY:}

          ---> =head1 SYNOPSIS

          ---> {:SCRIPT_NAME:} {:SYNTAX:}

          ---> =head1 DESCRIPTION

          ---> {:DESCRIBE_DETAILS:}

          ---> =cut

EOT
        perl -pi -e 's/^ +---> //' "${SCRIPT}"
        ;;
    *)
      ;;
    esac
  fi

  # Make readable
  test -r "${SCRIPT}" || chmod a+r "${SCRIPT}"

  # Make executable
  test -x "${SCRIPT}" || chmod a+x "${SCRIPT}"

  if [[ -n "${EDIT}" ]]; then
    "${EDIT}" "${SCRIPT}"
  fi
}

Mkbin "$@"
