#!/usr/bin/env bash
#
# Essential I/O functions for logging messages of all types including informational, warnings, errors, fatal
# - Comment
# - Color-Setup
# - Logfile
# - Log
# - Echo
# _do
# - Ruler
# - Info
# - Warn
# - Die
# - Debug
# - Assert
# - Fail
# - Pass
# - PassFail
# - Summary $0
# - HelpText

function Comment() {
  # Allow and ignore all arguments
  true;
}

function Realpath () {
  #@ Output the realpath name treating all arguments as a single filename specification
  #| Realpath FILENAME_SPECIFICATION
  /usr/bin/perl '-MCwd(abs_path)' -le "print abs_path(qq($*))"
}

function Color-Setup() {
  #@ Setup variables used to create color (or not)
  #| Color-Setup [off|on|bright]
  local USE_COLOR
  USE_COLOR=1
  case "$*" in
    off|OFF) USE_COLOR=0;;
    bright) USE_COLOR=2;;
    *) USE_COLOR=1;;
  esac
  if [[ -n ${NOCOLOR+x} ]]; then USE_COLOR=0; fi
  if [[ ${USE_COLOR} == 2 ]]; then
    # shellcheck disable=SC2034
    ESC=""
    BOLD="${ESC}[01m" NONE="${ESC}[00m"
    UNDR="${ESC}[04m" NONE="${ESC}[00m"
    CBLK="${ESC}[90m" NONE="${ESC}[00m"
    CRED="${ESC}[91m" NONE="${ESC}[00m"
    CGRN="${ESC}[92m" NONE="${ESC}[00m"
    CYLW="${ESC}[93m" NONE="${ESC}[00m"
    CBLU="${ESC}[94m" NONE="${ESC}[00m"
    CMAG="${ESC}[95m" NONE="${ESC}[00m"
    CCYN="${ESC}[96m" NONE="${ESC}[00m"
    CWHT="${ESC}[97m" NONE="${ESC}[00m"
    BBLK="${ESC}[100m" NONE="${ESC}[00m"
    BRED="${ESC}[101m" NONE="${ESC}[00m"
    BGRN="${ESC}[102m" NONE="${ESC}[00m"
    BYLW="${ESC}[103m" NONE="${ESC}[00m"
    BBLU="${ESC}[104m" NONE="${ESC}[00m"
    BMAG="${ESC}[105m" NONE="${ESC}[00m"
    BCYN="${ESC}[106m" NONE="${ESC}[00m"
    BWHT="${ESC}[107m" NONE="${ESC}[00m"
  elif [[ ${USE_COLOR} -gt 0 ]]; then
    # shellcheck disable=SC2034
    ESC=""
    BOLD="${ESC}[01m" NONE="${ESC}[00m"
    UNDR="${ESC}[04m" NONE="${ESC}[00m"
    CBLK="${ESC}[30m" NONE="${ESC}[00m"
    CRED="${ESC}[31m" NONE="${ESC}[00m"
    CGRN="${ESC}[32m" NONE="${ESC}[00m"
    CYLW="${ESC}[33m" NONE="${ESC}[00m"
    CBLU="${ESC}[34m" NONE="${ESC}[00m"
    CMAG="${ESC}[35m" NONE="${ESC}[00m"
    CCYN="${ESC}[36m" NONE="${ESC}[00m"
    CWHT="${ESC}[37m" NONE="${ESC}[00m"
    BBLK="${ESC}[40m" NONE="${ESC}[00m"
    BRED="${ESC}[41m" NONE="${ESC}[00m"
    BGRN="${ESC}[42m" NONE="${ESC}[00m"
    BYLW="${ESC}[43m" NONE="${ESC}[00m"
    BBLU="${ESC}[44m" NONE="${ESC}[00m"
    BMAG="${ESC}[45m" NONE="${ESC}[00m"
    BCYN="${ESC}[46m" NONE="${ESC}[00m"
    BWHT="${ESC}[47m" NONE="${ESC}[00m"
  else
    NONE=""
    BOLD=""
    UNDR=""
    CBLK=""
    CRED=""
    CGRN=""
    CYLW=""
    CBLU=""
    CMAG=""
    CCYN=""
    CWHT=""
    BBLK=""
    BRED=""
    BGRN=""
    BYLW=""
    BBLU=""
    BMAG=""
    BCYN=""
    BWHT=""
  fi
  export NONE BOLD UNDR CBLK CRED CGRN CYLW CBLU CMAG CCYN CWHT BBLK BRED BGRN BYLW BBLU BMAG BCYN BWHT
}

function Logfile() {
  #@ Logfile - Display, establish or close the logfile
  #| Logfile
  #| Logfile [--append|-a] FILENAME
  #| Logfile --off
  #| Logfile ""
  if [[ $# == 0 ]]; then
    if [[ -z "${LOGFILE}" ]]; then
      Info "Not currently logging"
    else
      Info "Logging to ${LOGFILE}"
    fi
    return
  fi
  if [[ "$1" =~ ^-{1,2}(off)? ]]; then
    LOGFILE=""
    return
  fi
  local APPEND PREV_LOGFILE
  APPEND=0
  if [[ "$1" =~ ^-{1,2}a(ppend)?$ ]]; then
    APPEND=1
    shift
  fi
  if [[ -n ${LOGFILE} ]]; then PREV_LOGFILE="${LOGFILE}"; else PREV_LOGFILE=""; fi
  LOGFILE=""
  if [[ $# -gt 0 && -z "${LOGFILE}" ]]; then
    # Figure out where to store logfile
    if [[ "${LOGFILE}" =~ ^/ ]]; then
      LOGFILE=""
    elif [[ -n "${LOGDIR}" ]]; then
      if [[ ! -d "${LOGDIR}" ]]; then mkdir -p "${LOGDIR}"; fi
      LOGFILE="$(Realpath "${LOGDIR}")/"
    else
      LOGFILE="$(Realpath .)/"
    fi
    # Append the filename ensuring suffix is .log
    LOGFILE="${LOGFILE}${1//.log/}.log"
  fi
  if [[ -n "${PREV_LOGFILE}" && "${PREV_LOGFILE}" != "${LOGFILE}" ]]; then
    builtin printf "\n# Closed %s\n" "$(date)" >> "${PREV_LOGFILE}"
    builtin printf "Closed %s\n" "${PREV_LOGFILE}"
  elif [[ -z "${LOGFILE}" ]]; then
    builtin echo "Error: Must specify a valid logfile name" 1>&2
    exit 1
  fi
  if [[ -n "${LOGFILE}" ]]; then
    test "${APPEND}" -eq 0 && rm -f "${LOGFILE}"
    builtin printf "# Logfile for %s created on %s\n\n" "$1" "$(date)" >> "${LOGFILE}"
    builtin printf "Logging to %s\n" "${LOGFILE}"
  fi
}

function Log() {
  #@ Send text to current logfile if $LOGFILE is defined
  #| Log [-n] "MESSAGE"
  #| COMMAND | Log
  if [[ -z "${LOGFILE}" ]]; then return; fi
  local OPT
  if [[ "$1" == "-n" ]]; then OPT="$1"; shift; fi
  if [[ $# == 0 ]]; then # pipe
    if [[ -f "${LOGFILE}" ]]; then tee -a "${LOGFILE}"; else cat >"${LOGFILE}"; fi
  else
    if [[ -f "${LOGFILE}" ]]; then
      if [[ "${OPT}" == "-n" ]]; then
        builtin echo -n "$@" >>"${LOGFILE}";
      else
        builtin echo    "$@" >>"${LOGFILE}";
      fi
    fi
  fi
}

function Echo() {
  #@ Echo text, but also sends to Log
  #| Echo [-n] TEXT
  local OPT
  if [[ "$1" == "-n" ]]; then OPT="$1"; shift; fi
  if [[ "${OPT}" == "-n" ]]; then
    builtin echo -n "$*"; Log  -n "$*"
  else
    builtin echo "$*"; Log "$*"
  fi
  }

function Printf() {
  #@ Printf with logging
  local TEXT
  # shellcheck disable=SC2059
  TEXT="$(builtin printf "$@")"
  builtin echo "${TEXT}"; Log "${TEXT}"
}

function _do() {
  #@ Echo and then execute arguments as a command
  #| _do COMMAND [ARGS]
  local NX
  if [[ -n "${NOTREALLY}" ]]; then NX="-"; fi
  if [[ "$1" == "-n" ]]; then NX="-"; shift; fi
  if [[ "${NX}" == "-" ]]; then
    Echo "${CBLU}${NX}%${NONE} $*"
    return;
  else
    Echo "${CCYN}${NX}%${NONE} ${BOLD}$*${NONE}"
  fi
  "$@"
}

function Fail() {
  return 1
}

function Pass() {
  return 0
}

function Info() {
  #@ Echo tagged informational message (i.e., SC_REPORT_INFO) - logged
  #| Info [-(red|grn|blu|ylw|cyn|mag)] MESSAGE
  if [[ -n "${VERBOSITY+x}" || "${VERBOSITY}" -lt 0 ]]; then
    return 0
  fi
  local PRE
  # Test for color prefix
  case "$1" in
    -pre) PRE="${2}"    ; shift  ; shift ;;
    -cyn) PRE="${CCYN}" ; shift ;;
    -red) PRE="${CRED}" ; shift ;;
    -grn) PRE="${CGRN}" ; shift ;;
    -ylw) PRE="${CYLW}" ; shift ;;
    -blu) PRE="${CBLU}" ; shift ;;
    -mag) PRE="${CMAG}" ; shift ;;
    -wht) PRE="${CWHT}" ; shift ;;
    *) PRE="${NONE}" ;;
  esac
  Echo "${CGRN}Info: ${PRE}$*${NONE}"
}

function PassFail() { # Reports success or failure
  # shellcheck disable=SC2181
  if [[ $# == 0 ]]; then
    if [[ $? == 0 ]]; then Info "${BOLD}${CGRN}success${NONE}"; else Info "${BOLD}${CRED}failure${NONE}"; fi
  else
    if [[ $? == 0 ]]; then Info "$* ${BOLD}${CGRN}success${NONE}"; else Info "$* ${BOLD}${CRED}failure${NONE}"; fi
  fi
}

function Debug() {
  #@ Echo tagged debug message iff debugging (i.e., $DEBUG defined and non-zero)
  #| Debug MESSAGE
  if [[ -n "${DEBUG}" && "${DEBUG}" != 0 ]]; then
    Echo "${CRED}Debug: ${NONE}$*${NONE}"
  fi
}

function Ruler() {
  local ARGS SEP MAX LIN WID
  SEP="-" # Default
  MAX=80 # TODO: Change to match terminal width
  local PRE
  PRE=""
  # Test for color prefix
  case "$1" in
    -pre) PRE="${2}"    ; shift  ; shift ;;
    -cyn) PRE="${CCYN}" ; shift ;;
    -red) PRE="${CRED}" ; shift ;;
    -grn) PRE="${CGRN}" ; shift ;;
    -ylw) PRE="${CYLW}" ; shift ;;
    -blu) PRE="${CBLU}" ; shift ;;
    *) PRE="" ;;
  esac
  Printf "%s" "${PRE}"
  # Grab separator
  if [[ $# -gt 0 && "${#1}" == 1 ]]; then
    SEP="$1"
    shift
  fi
  ARGS="$*"
  if [[ $# != 0 ]]; then
    WID=${#ARGS}
    MAX=$(( MAX - WID - 4 ))
  fi
  LIN="$(/usr/bin/perl -le 'my ($w,$s)=@ARGV;printf(qq{%${w}.${w}s},${s}x${w})' "${MAX}" "${SEP}")"
  if [[ $# == 0 ]]; then
    Printf "%s%s\n" "${LIN}" "${NONE}"
  else
    Printf "%s%s %s %s%s\n" "${SEP}" "${SEP}" "${ARGS}" "${LIN}" "${NONE}"
  fi
}

# Ensure that error messages are clearly seen
function Die() {
  Echo -n "${CRED}"
  Ruler '!'
  Echo "${CRED}Fatal: $*${NONE}" 1>&2
  exit 1
}

function Assert() {
  #@ Similar to sc_assert
  if [[ -z "${NDEBUG}" ]]; then return; fi
  # shellcheck disable=SC218
  test "$@" && return
  local FNC FIL LNO
  FNC="${FUNCNAME[1]}"
  FIL="${BASH_SOURCE[1]}"
  LNO="${BASH_LINENO[0]}"
  Die "Failed assertion '$*' from ${FNC} in ${FIL}:${LNO}"
}

function Error() {
  #@ Echo tagged error message (i.e., SC_REPORT_ERROR) - logged and counted
  #| Error MESSAGE
  if [[ -z "${ERRORS}" ]]; then ERRORS=0; fi
  (( ++ERRORS ))
  export ERRORS
  Echo -n "${CRED}"
  Ruler '!'
  Echo "${CRED}Error #${ERRORS}: ${NONE}$*${NONE}" 1>&2
}

function Warn() {
  #@ Echo tagged warning message (i.e., SC_REPORT_WARNING) - logged and counted
  #| Error MESSAGE
  if [[ -z "${WARNINGS}" ]]; then WARNINGS=0; fi
  (( ++WARNINGS ))
  export WARNINGS
  Echo -n "${CRED}"
  Ruler '?'
  Echo "${CRED}Warning: ${NONE}$*${NONE}" 1>&2
}

function Summary() {
  Assert $# != 0
  Echo "Execution summary for ${1}:"
  shift
  Echo " ${WARNINGS} warnings"
  Echo -n "  ${ERRORS} errors"
  local RESULT
  if [[ ${ERRORS} == 0 ]]; then Echo " - passing"; RESULT=0;
  else                          Echo " - failing"; RESULT=1;
  fi
  if [[ $# != 0 ]]; then Echo "$*"; fi
  return "${RESULT}"
}

function HelpText() {
  local HELPSCRIPT
  if [[ "$1" == "-md" ]]; then
    shift
    # shellcheck disable=SC2016
    HELPSCRIPT='if (/begin_markdown/../end_markdown/){ next if m/(begin|end)_markdown/; print; }'
  else
    # shellcheck disable=SC2016
    HELPSCRIPT='$p = $ARGV; $p =~ s{.*/}{}; if( $_ =~ s{^ *#\|}{} ){ $_ =~ s{\$0}{$p}; print; }'
  fi
  Assert $# -gt 0
  /usr/bin/perl -ne "${HELPSCRIPT}" "$@";
}

# vim:nospell
